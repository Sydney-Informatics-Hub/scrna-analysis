---
title: "scRNA Analysis - 04 - Integrated Dataset Analysis"
author: "Sydney Informatics Hub"
format: html
---

This notebook is designed to run downstream analyses on an integrated Seurat dataset. This includes automatic and (optionally) manual cell type annotation, cell cycle annotation, differential gene expression analysis, and pathway analysis.

## Imports

While working through this notebook manually, you will need to run the following block of code to import all the necessary R libraries and helper functions:

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(Seurat)
library(scuttle)
library(SingleR)
source("R/helpers.R")
source("R/shinyapps.R")
```

## Read in dataset

```{r inputs}
dataset <- "outputs/integrated_dataset.filtered_clustered.doublets_detected.integrated.Rds"

# Load data
integrated <- readRDS(dataset)
```

## Annotation 1: Cell Cycle

Cell cycle annotation is a common step, particularly for cancer data sets.

```{r cell_cycle_scoring}
gene2ens <- integrated@assays$RNA@meta.data
s.genes.ens <- gene2ens$gene_versions[match(cc.genes$s.genes, gene2ens$gene_symbols)]
s.genes.ens <- s.genes.ens[!is.na(s.genes.ens)]
g2m.genes.ens <- gene2ens$gene_versions[match(cc.genes$g2m.genes, gene2ens$gene_symbols)]
g2m.genes.ens <- g2m.genes.ens[!is.na(g2m.genes.ens)]

integrated <- CellCycleScoring(
  integrated,
  s.features = s.genes.ens,
  g2m.features = g2m.genes.ens
)
```

### Plot cell cycle annotations

```{r plot_cell_cycle_scoring}
DimPlot(integrated, reduction = "umap", group.by = "Phase")
```

## Annotation 2: Automatic cell type assignment with HPCA

This step will assign cell types to each cell using the `SingleR` and `celldex` packages and the HPCA database.

```{r annotate_cell_types_hpca}
ref <- celldex::HumanPrimaryCellAtlasData()

sce <- as.SingleCellExperiment(integrated, assay = "RNA")
sceM <- logNormCounts(sce)

# Map Ensembl IDs to gene IDs
ens2gene <- AnnotationDbi::mapIds(
  EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86,
  keys = rownames(sce),
  column = "SYMBOL",
  keytype = "GENEID"
)
stopifnot(all(rownames(sceM) == names(ens2gene)))
keep <- !is.na(ens2gene)
ens2gene <- ens2gene[keep]
sceM <- sceM[keep,]
rownames(sceM) <- ens2gene

# Add the main-level annotations
predicted <- SingleR(test = sceM, ref = ref, labels = ref$label.main)
keep <- table(predicted$labels) > 10  # NOTE: Should we change this?
integrated$SingleR.hpca_main <- ifelse(keep[predicted$labels], predicted$labels, "Other")

# Also add the fine-level annotations
predicted <- SingleR(test = sceM, ref = ref, labels = ref$label.fine)
keep <- table(predicted$labels) > 10  # NOTE: Should we change this?
integrated$SingleR.hpca_fine <- ifelse(keep[predicted$labels], predicted$labels, "Other")

rm(sce, sceM, ens2gene, keep, predicted, ref)
```

### Plot cell type assignment

```{r plot_cell_types_hpca}
cluster_res_file <- "inputs/integrated_cluster_resolution.txt"
cluster_res <- scan(cluster_res_file, numeric())
cluster_name <- paste0("SCT_snn_res.", cluster_res)

DimPlot(
  integrated,
  reduction = "umap",
  group.by = c(cluster_name, "SingleR.hpca_main"),
  label = TRUE,
  repel = TRUE,
  label.box = TRUE
)
```

### Print table of cluster assignments

```{r print_cluster_assignments}
integrated@meta.data %>%
  dplyr::select(any_of(cluster_name), SingleR.hpca_main) %>%
  group_by(.data[[cluster_name]], SingleR.hpca_main) %>%
  summarise(n_cells = n()) %>%
  pivot_wider(names_from = cluster_name, values_from = n_cells)


integrated@meta.data %>%
  dplyr::select(any_of(cluster_name), SingleR.hpca_fine) %>%
  group_by(.data[[cluster_name]], SingleR.hpca_fine) %>%
  summarise(n_cells = n()) %>%
  pivot_wider(names_from = cluster_name, values_from = n_cells)
```

## Annotation 3: Manual cluster-level annotation with curated gene lists

If you have a list of cell types with curated cell markers available, you can use the template TSV file `inputs/custom_markers.tsv` to define these gene programs. The TSV file contains two columns with the headers `cell_type` and `gene_ids`. The `gene_ids` column should contain all of the marker genes associated with the cell type, separated by commas. For example:

```
cell_type gene_ids
T_NK  CD3D,CD3E,CD3G,CD247
B_cells CD79A,CD79B,IGHM,IGHD
Myeloid LYZ,S100A8,S100A9,CD14
Fibroblasts COL1A1,COL1A2,COL3A1,ACTA2
Endothelial PECAM1,CD34,CDH5,VWF
```

If you don't want to run custom cell type assignment, delete or rename the template file, then skip ahead to the section "[Choose cell annotations to use](#choose_annots)"

```{r define_custom_programs}
custom_marker_genes_file <- "inputs/custom_markers.tsv"
run_custom_annotation <- file.exists(custom_marker_genes_file)
available_annots <- c("Phase", "SingleR.hpca_main", "SingleR.hpca_fine")
```

```{r read_custom_programs, echo = run_custom_annotation, eval = run_custom_annotation}
custom_marker_genes <- read_tsv(custom_marker_genes_file)

custom_programs <- custom_marker_genes$cell_type
custom_marker_genes <- strsplit(custom_marker_genes$gene_ids, ",")
names(custom_marker_genes) <- custom_programs

custom_marker_genes
```

```{r get_ensembl_gene_ids, echo = run_custom_annotation, eval = run_custom_annotation}
custom_marker_genes_ens <- lapply(custom_marker_genes, function(g) { gene2ens$gene_versions[match(g, gene2ens$gene_symbols)] })
custom_marker_genes_ens
```

```{r score_cells, echo = run_custom_annotation, eval = run_custom_annotation}
integrated <- AddModuleScore(
  integrated,
  features = custom_marker_genes_ens,
  name = names(custom_marker_genes_ens)
)

# Remove numeric suffix from cluster names
numeric_suffix_clusters <- paste0(names(custom_marker_genes_ens), 1:length(custom_marker_genes_ens))
stopifnot(all(numeric_suffix_clusters %in% colnames(integrated@meta.data)))  # Sanity check
colnames(integrated@meta.data)[colnames(integrated@meta.data) %in% numeric_suffix_clusters] <- names(custom_marker_genes_ens)
stopifnot(all(names(custom_marker_genes_ens) %in% colnames(integrated@meta.data)))  # Sanity check
```

```{r summarise_scores, echo = run_custom_annotation, eval = run_custom_annotation}
scores <- integrated@meta.data %>%
  dplyr::select(Cluster = cluster_name, all_of(custom_programs)) %>%
  pivot_longer(
    cols = all_of(custom_programs),
    names_to = "cell_type",
    values_to = "score"
  ) %>%
  group_by(Cluster, cell_type) %>%
  summarise(
    avg_score    = mean(score, na.rm = TRUE),
    median_score = median(score, na.rm = TRUE),
    sd_score     = sd(score, na.rm = TRUE),
    n_cells      = n(),
    .groups      = "drop"
  )

scores
```

```{r plot_cluster_scores, echo = run_custom_annotation, eval = run_custom_annotation}
ggplot(scores, aes(x = Cluster, y = cell_type, fill = median_score)) +
  geom_tile() +
  theme_light() +
  ggtitle("Cluster Scores") +
  scale_fill_gradientn(colours = c("lightblue","beige","red"))
```

### Predict the cell type using the maximum score

The following code will determine the cell type that each cell most strongly aligns with. Where more than 2 cell types have been provided, a Z-score will also be calculated to give a measure of how strongly the cell aligns with the top-scoring program, relative to the remaining programs.

```{r get_max_scores_per_cluster, echo = run_custom_annotation, eval = run_custom_annotation}
argmax_scores <- apply(integrated@meta.data[custom_programs], 1, which.max) %>% unlist
integrated$cell_type.max_score <- custom_programs[argmax_scores]

# Also calculate how much the top two scores differ
# Can only calculate when more than 3 cell programs are present
# Determines how many MADs the top 2 scores differ by
# If they differ by less than 1 MAD, mark as ambiguous
if (length(custom_programs) > 3) {
  s <- integrated@meta.data[custom_programs]
  integrated$cell_type.top_2_score_mad_diff <- apply(s, 1, function(x) {
    xv <- unlist(x)
    mad_x <- stats::mad(xv, constant = 1)
    top_2_x <- xv[order(xv, decreasing = TRUE)][1:2]
    return((top_2_x[1] - top_2_x[2]) / mad_x)
  }) %>% unlist
  
  # If the top two scores are too close, mark the cell as ambiguous
  integrated@meta.data <- integrated@meta.data %>% mutate(
    cell_type.mark_ambiguous = case_when(
      cell_type.top_2_score_mad_diff >= 1 ~ cell_type.max_score,
      .default = "Ambiguous"
    )
  )
  
  available_annots <- c(available_annots, "cell_type.max_score", "cell_type.mark_ambiguous")
  integrated@meta.data[c(custom_programs, "SingleR.hpca_main", "SingleR.hpca_fine", "cell_type.max_score", "cell_type.top_2_score_mad_diff", "cell_type.mark_ambiguous")]
} else {
  available_annots <- c(available_annots, "cell_type.max_score")
  integrated@meta.data[c(custom_programs, "SingleR.hpca_main", "SingleR.hpca_fine", "cell_type.max_score")]
}
```

```{r plot_custom_cell_types, echo = run_custom_annotation, eval = run_custom_annotation}
dim_groups <- c(cluster_name, "SingleR.hpca_main", "cell_type.max_score")
if (length(custom_programs) > 3) {
  dim_groups <- c(dim_groups, "cell_type.mark_ambiguous")
}
DimPlot(
  integrated,
  reduction = "umap",
  group.by = dim_groups,
  label = TRUE,
  repel = TRUE,
  label.box = TRUE
)
rm(dim_groups)
```

```{r plot_scores_per_cell_type, echo = run_custom_annotation, eval = run_custom_annotation}
for (ct in custom_programs) {
  FeaturePlot(
    integrated,
    reduction = "umap",
    features = c(ct)
  ) %>% print
}
```

## Choose cell annotations to use {#choose_annots}

You currently have the following cell annotations to choose from:

```{r print_cell_type_annotations, echo = FALSE}
original_samplesheet <- "inputs/samplesheet.csv"
original_samplesheet <- read_csv(original_samplesheet, show_col_types = FALSE)
additional_annots <- colnames(original_samplesheet)
additional_annots <- additional_annots[! additional_annots %in% c("sample", "rds_path")]
available_annots <- unique(c(additional_annots, available_annots))
rm(additional_annots)

cat(paste(available_annots, collapse = ", "))
```

Use the following code chunk to define the annotations you want to use for downstream analyses, including differential gene expression analysis, pathway analysis, and gene set enrichment analysis. You can supply more than one annotation to use.

```{r define_annotation_for_analyses}
main_annots <- c(
  "SingleR.hpca_main",
  "tumor"
)
```

## Pseudobulking

We now aggregate the expression of cells, grouped by their original sample name and the annotations you just chose.

```{r aggregate_expression}
pseudo <- AggregateExpression(
  integrated,
  assays = "RNA",
  return.seurat = TRUE,
  group.by = c("orig.ident", main_annots)
)

Cells(pseudo)
```

For differential expression comparisons, we will want to create a further grouping that excludes the sample name. For example, if you have aggregated cells into groups defined by their sample name, HPCA main annotation, and tumor status, you would create a new grouping of just HPCA main annotation and tumor status, so that all tumor-positive cells of a given cell type can be compared with all of the the tumor negative cells of the same cell type.

If you have a more complex analysis in mind, you can modify the code in the next chunk to reflect the groups that you want to compare. Otherwise the default code will simply remove the sample name level from the groups.

```{r define_comparison_groupings}
# Change this if you wish to create different groups other than what is defined in the variable `main_annots`
comparison_groupings <- c(
  main_annots
)

comparison_group <- pseudo@meta.data %>%
  select(all_of(comparison_groupings)) %>%
  unite(comparison_group, sep = "_")
pseudo$comparison_group <- comparison_group$comparison_group

rm(comparison_group)

Idents(pseudo) <- "comparison_group"
```

Finally, we need to re-normalise the data

```{r }
pseudo <- NormalizeData(pseudo, assay = "RNA", verbose = TRUE)
```

## Differential gene expression analysis

```{r}

```

## Pathway analysis

```{r}

```

### Pathway over-representation analysis (ORA)

```{r}

```

## Gene set enrichment analysis (GSEA)

```{r}

```

## Write data to file

```{r save_data, eval = FALSE}
dir.create("outputs")
SaveSeuratRds(integrated, "outputs/integrated_dataset.filtered_clustered.doublets_detected.integrated.analysed.Rds")
```
