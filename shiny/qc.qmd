---
title: "scRNA sequencing - initial QC and filtering"
author: "Sydney Informatics Hub"
format: html
server: shiny
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(shiny)
library(tidyverse)
library(Seurat)
library(hdf5r)
library(DT)
library(clustree)
library(glmGamPoi)
```

```{r helper_functions}
#| context: server
readRDS_update_metadata <- function(path_to_rds, sample_name, mt_pattern = "^MT-", metadata = NULL) {
  # Read RDS, add metadata if requested
  so <- readRDS(path_to_rds)
  # Ensure sample names are assigned for plotting
  so@project.name <- sample_name
  so$orig.ident <- as.factor(sample_name)
  # Add MT percentage (optional)
  if (!is.null(mt_pattern)) {
    # Check if using gene names or accession IDs
    if (!all(rownames(so@assays$RNA) == so@assays$RNA@meta.data$gene_symbols)) {
      rn <- rownames(so@assays$RNA)
      rownames(so@assays$RNA) <- so@assays$RNA@meta.data$gene_symbols
      so$percent.mt <- Seurat::PercentageFeatureSet(so, pattern = "^MT-")
      rownames(so@assays$RNA) <- rn
    } else {
      so$percent.mt <- Seurat::PercentageFeatureSet(so, pattern = "^MT-")
    }
  }
  # Add additional metadata (optional)
  if (!is.null(metadata)) {
    for (md in names(metadata)) {
      so[[md]] = metadata[[md]]
    }
  }
  return(so)
}

get_metadata_df <- function(all_seurats) {
  # combines all metadata cols across prepare it for plotting compatibility with ggplot
  lapply(all_seurats, function(seurat_obj) {
    seurat_obj@meta.data %>%
      rownames_to_column(var = "barcode")
  }) %>%
    bind_rows()
}

find_min_pc <- function(stdvs) {
  percent_stdv <- (stdvs/sum(stdvs)) * 100
  cumulative <- cumsum(percent_stdv)
  co1 <- which(cumulative > 90 & percent_stdv < 5)[1]
  co2 <- sort(which((percent_stdv[1:length(percent_stdv) - 1] -
                       percent_stdv[2:length(percent_stdv)]) > 0.1),
              decreasing = T)[1] + 1
  min_pc <- min(co1, co2)
  print(min_pc)
}

SCTransform_reduce_dims <- function(so) {
  # Normalise with SCTransform and reduce dimensions with PCA.
  sct <-
    Seurat::SCTransform(so, vars.to.regress = c("percent.mt"), verbose = F) |>
    Seurat::RunPCA()

  # Calculate the minimum number of PCs that explain the majority of the variation
  min_pc <- find_min_pc(sct@reductions$pca@stdev)

  sct <-
    Seurat::RunUMAP(sct, dims = 1:min_pc, verbose = F) |>
    Seurat::FindNeighbors(dims = 1:min_pc, verbose = F)

  return(sct)
}
```

## Define inputs

Use the following file input to select a CSV sample sheet defining your samples and any metadata you would like to annotate them with. The CSV should have at least two columns, `sample` and `rds_path`. Additional columns will be treated as metadata variables that will be added to the Seurat objects. The value under the `sample` column will be used as the sample's name in the Seurat object. The value under the `rds_path` column should be the path to the RDS file generated by `nf-core/scrnaseq`. For example:

```
sample,rds_path,tumour
normal_sample,/path/to/normal_sample.rds,neg
tumour_sample,/path/to/tumour_sample.rds,pos
```

```{r inputs, echo = FALSE}
# samplesheet <- "data/samplesheet.csv"
fileInput("samplesheet", "Choose your samplesheet CSV")
dataTableOutput("sample_table")
textOutput("data_loaded")
```

```{r inputs_server}
#| context: server
values <- reactiveValues(
  samplesheet = tibble(sample = character(), rds_path = character()),
  samplesheet_name = "",
  all_seurat_objects = list(),
  all_filtered_seurat_objects = list(),
  all_metadata = tibble(barcode = character(), orig.ident = character(), nCount_RNA = numeric(), nFeature_RNA = numeric(), sample = character()),
  filter_table = tibble(sample = character(), n_cells_pre_filter = numeric(), n_cells_post_filter = numeric()),
  filter_plot = NULL,
  ready = FALSE,
  ready_for_init_sct = FALSE,
  cluster_res = seq(0.6, 2.4, 0.2),
  all_init_sct = list(),
  all_init_clustree = list(),
  processing = FALSE
)

observeEvent(input$samplesheet, {
  if (is.null(input$samplesheet$datapath)) {
    return(NULL)
  }
  values$ready <- FALSE
  values$samplesheet <- read_csv(input$samplesheet$datapath)
  values$samplesheet_name <- input$samplesheet$name
  values$all_seurat_objects <- lapply(transpose(values$samplesheet), function(x) {
    md <- x[! names(x) %in% c("sample", "rds_path")]
    readRDS_update_metadata(
      path_to_rds = x$rds_path,
      sample_name = x$sample,
      metadata = md
    )
  })
  names(values$all_seurat_objects) <- lapply(values$all_seurat_objects, function(s) {
    s@meta.data$orig.ident[[1]]
  }) %>% unlist
  values$all_metadata <- get_metadata_df(values$all_seurat_objects)
  values$ready <- TRUE
})

output$sample_table <- renderDataTable({ datatable(values$samplesheet) })
output$data_loaded <- renderText({
  if (values$ready) {
    paste("Data loaded and ready:", values$samplesheet_name)
  } else {
    paste("No data loaded, not ready.")
  }
})
output$all_metadata <- renderDataTable({ datatable(values$all_metadata) })
```

Sample metadata:

```{r display_metadata, echo = FALSE}
dataTableOutput("all_metadata")
```

## Initial QC

First, we can check the number of cells each sample has:

```{r total_cells_server}
#| context: server
get_total_cells <- reactive({
  if (values$ready) {
    total_cells <- lapply(values$all_seurat_objects, function(x) table(x$orig.ident)) %>% unlist
    tibble(sample = names(total_cells), n_cells = total_cells)
  } else {
    tibble(sample = character(), n_cells = numeric())
  }
})
output$total_cells <- renderDataTable({ datatable(get_total_cells()) })
```

```{r total_cells, echo = FALSE}
dataTableOutput("total_cells")
```

Next, plot the distribution of nCount_RNA, nFeature_RNA, and (if available), percent.mt for each sample:


```{r metadata_distributions_server}
#| context: server
get_md_dist_plot <- reactive({
  if (!values$ready) {
    return(NULL)
  }

  md <- values$all_metadata
  md_cols <- c("nCount_RNA", "nFeature_RNA", "percent.mt")
  md_cols <- md_cols[md_cols %in% colnames(md)]

  p_md <- md %>%
    pivot_longer(cols = all_of(md_cols)) %>%
    ggplot(aes(x = orig.ident, y = value, fill = orig.ident, colour = orig.ident)) +
    facet_wrap(~ name, scales = "free_y") +
    theme_light() +
    theme(legend.position = "none")

  if (input$md_dist_plot_log_y) {
    p_md <- p_md + scale_y_log10()
  }
  if (input$md_dist_plot_jitter) {
    p_md <- p_md + geom_jitter(size = 0.1, alpha = 0.7, colour = "lightgrey")
  }

  p_md + geom_violin(alpha = 0.1)
})

output$md_dist_plot <- renderPlot({ get_md_dist_plot() })
```

```{r metadata_distributions, echo = FALSE}
checkboxInput("md_dist_plot_log_y", "Display Y-axis as log-scale?", value = FALSE)
checkboxInput("md_dist_plot_jitter", "Display jitter plots?", value = FALSE)
plotOutput("md_dist_plot")
```
### Identify filtering thresholds

You can use the following plot and sliders to determine thresholds to use for filtering your data:

```{r qc_thresholds_server}
#| context: server
output$qc_threshold_plot_ncount <- renderUI({
  max_ncount <- max(values$all_metadata$nCount_RNA)
  max_ncount_adj <- round(max_ncount/50) * 50

  sliderInput(
    "qc_threshold_plot_ncount",
    "nCount_RNA",
    min = 0,
    max = max_ncount_adj,
    value = c(0, max_ncount_adj),
    step = 50,
    ticks = FALSE,
    width = "80%"
  )
})

output$qc_threshold_plot_nfeature <- renderUI({
  max_nfeature <- max(values$all_metadata$nFeature_RNA)
  max_nfeature_adj <- round(max_nfeature/50) * 50

  sliderInput(
    "qc_threshold_plot_nfeature",
    "nFeature_RNA",
    min = 0,
    max = max_nfeature_adj,
    value = c(0, max_nfeature_adj),
    step = 50,
    ticks = FALSE,
    width = "80%"
  )
})

output$qc_threshold_plot_mt <- renderUI({
  sliderInput(
    "qc_threshold_plot_mt",
    "mt %",
    min = 0,
    max = 100,
    value = c(0, 100),
    step = 1,
    ticks = FALSE,
    width = "80%"
  )
})

get_qc_threshold_plot <- reactive({
  if (!values$ready) {
    return(NULL)
  }

  md <- values$all_metadata
  p <- md %>%
    filter(nCount_RNA > input$qc_threshold_plot_ncount[1], nCount_RNA < input$qc_threshold_plot_ncount[2]) %>%
    filter(nFeature_RNA > input$qc_threshold_plot_nfeature[1], nFeature_RNA < input$qc_threshold_plot_nfeature[2]) %>%
    filter(percent.mt > input$qc_threshold_plot_mt[1], percent.mt < input$qc_threshold_plot_mt[2]) %>%
    ggplot(aes(x = nCount_RNA, y = nFeature_RNA, colour = percent.mt)) +
    geom_point(size = 0.25, alpha = 0.8) +
    scale_color_viridis_c() +
    facet_wrap(~ orig.ident) +
    theme_light()

  if (input$qc_threshold_plot_log_x) {
    p <- p + scale_x_log10()
  }
  if (input$qc_threshold_plot_log_y) {
    p <- p + scale_y_log10()
  }

  p
})
output$qc_threshold_plot <- renderPlot({ get_qc_threshold_plot() })
```

```{r qc_thresholds, echo = FALSE}
checkboxInput("qc_threshold_plot_log_x", "Display X-axis as log-scale?", value = TRUE)
checkboxInput("qc_threshold_plot_log_y", "Display Y-axis as log-scale?", value = TRUE)

uiOutput("qc_threshold_plot_ncount")

uiOutput("qc_threshold_plot_nfeature")

uiOutput("qc_threshold_plot_mt")

plotOutput("qc_threshold_plot")
```

When you have chosen appropriate thresholds, click the button below to apply the filters to your dataset. If you adjust your thresholds and click again, the new filters will overwrite the old ones.

```{r apply_filter_server}
#| context: server
output$apply_filter_button <- renderUI({
  actionButton("apply_filter", "Apply Filter", disabled = (!values$ready || values$processing))
})

observeEvent(input$apply_filter, {
  if (!values$ready) {
    return(NULL)
  }

  values$processing <- TRUE
  values$ready_for_init_sct <- FALSE

  values$all_seurat_objects <- lapply(values$all_seurat_objects, function(s) {
    s2 <- s
    s2@meta.data <- s2@meta.data %>%
    mutate(
      qc_threshold = case_when(
        percent.mt > input$qc_threshold_plot_mt[1] &
          percent.mt < input$qc_threshold_plot_mt[2] &
          nFeature_RNA > input$qc_threshold_plot_nfeature[1] &
          nFeature_RNA < input$qc_threshold_plot_nfeature[2] &
          nCount_RNA > input$qc_threshold_plot_ncount[1] &
          nCount_RNA < input$qc_threshold_plot_ncount[2] ~ "keep",
        TRUE ~ "remove"
      )
    )
    s2
  })

  values$all_filtered_seurat_objects <- lapply(values$all_seurat_objects, function(s) {
    subset(s, subset = (qc_threshold == "keep"))
  })
  
  ncells_pre_filtered <- lapply(values$all_seurat_objects, function(s) {
    nrow(s@meta.data)
  })

  # Generate a table of pre-and post-filter cell counts
  filter_table <- lapply(values$all_filtered_seurat_objects, function(s) {
    s_name <- s@meta.data$orig.ident[[1]]
    ncells_post_filtered <- nrow(s@meta.data)
    return(data.frame(sample = s_name, n_cells_pre_filter = ncells_pre_filtered[[s_name]], n_cells_post_filter = ncells_post_filtered))
  })
  values$filter_table <- do.call(rbind, filter_table)

  # Generate a static filter plot
  md <- get_metadata_df(values$all_filtered_seurat_objects)
  p <- md %>%
    ggplot(aes(x = nCount_RNA, y = nFeature_RNA, colour = percent.mt)) +
    geom_point(size = 0.25, alpha = 0.8) +
    scale_color_viridis_c() +
    facet_wrap(~ orig.ident) +
    theme_light()

  if (input$qc_threshold_plot_log_x) {
    p <- p + scale_x_log10()
  }
  if (input$qc_threshold_plot_log_y) {
    p <- p + scale_y_log10()
  }

  p

  values$filter_plot <- p

  # Flag that we are now ready to apply SCTransform and initial clustering
  values$processing <- FALSE
  values$ready_for_init_sct <- TRUE
})

output$filter_table <- renderDataTable({ datatable(values$filter_table) })
output$filtered_plots <- renderPlot({ values$filter_plot })
```

```{r apply_filter, echo = FALSE}
uiOutput("apply_filter_button")
dataTableOutput("filter_table")
plotOutput("filtered_plots")
```

## Initial SCTransform and clustering

We can now perform an initial run of normalisation and clustering to detect any potential clusters of cells that should be removed.

```{r init_sct_reduce_dims_server}
#| context: server
output$run_init_sct_cluster_button <- renderUI({
  actionButton("run_init_sct_cluster", "Run Initial SCTransform and Clustering", disabled = (!values$ready_for_init_sct || values$processing))
})

options(future.globals.maxSize = 1000*1024^2)
observeEvent(input$run_init_sct_cluster, {
  if (!values$ready_for_init_sct) {
    return(NULL)
  }
  
  values$processing <- TRUE

  values$all_init_sct <- lapply(values$all_filtered_seurat_objects, function(s) {
    # Run SCTransform and find clusters
    s_sct <- SCTransform_reduce_dims(s)
    s_sct <- FindClusters(s_sct, resolution = values$cluster_res, verbose = 0)
    s_sct
  })
  
  values$all_init_clustree <- lapply(values$all_init_sct, function(s) {
    s_name <- s@meta.data$orig.ident[[1]]
    clustree::clustree(s, prefix = "SCT_snn_res.") + ggtitle(s_name)
  })
  
  values$processing <- FALSE
})

output$init_seurat_sct_selector <- renderUI({
  selectInput(
    "init_seurat_sct_selector",
    "Select Seurat object:",
    choices = sapply(values$all_init_sct, function(s) { s@meta.data$orig.ident[[1]] })
  )
})

output$init_seurat_clustree <- renderPlot({ values$all_init_clustree[[input$init_seurat_sct_selector]] })

output$init_seurat_cluster_selector <- renderUI({
  selectInput(
    "init_seurat_cluster_selector",
    "Select cluster resolution:",
    choices = values$cluster_res
  )
})

output$init_seurat_cluster_plot <- renderPlot({
  s <- values$all_init_sct[[input$init_seurat_sct_selector]]
  if (is.null(s)) {
    return(NULL)
  }
  DimPlot(
    object = s,
    reduction = "umap",
    group.by = paste0("SCT_snn_res.", input$init_seurat_cluster_selector),
    label = TRUE
  )
})

output$init_seurat_cluster_scatter_plots <- renderPlot({
  s <- values$all_init_sct[[input$init_seurat_sct_selector]]
  if (is.null(s)) {
    return(NULL)
  }
  meta <- s@meta.data
  ggplot(meta, aes(x = nCount_RNA, y = nFeature_RNA, col = percent.mt)) +
    geom_point(size = 0.3) +
    facet_wrap(paste0("SCT_snn_res.", input$init_seurat_cluster_selector)) +
    scale_x_log10() +
    scale_y_log10() +
    theme_light() +
    viridis::scale_color_viridis() +
    annotation_logticks(side = "lb", colour = "lightgrey")
})
```

```{r init_sct_reduce_dims, echo = FALSE}
uiOutput("run_init_sct_cluster_button")
```

```{r init_sct_clustree_server, echo = FALSE}
uiOutput("init_seurat_sct_selector")
plotOutput("init_seurat_clustree")
uiOutput("init_seurat_cluster_selector")
plotOutput("init_seurat_cluster_plot")
plotOutput("init_seurat_cluster_scatter_plots")
```




<!-- ```{r echo = FALSE, eval = FALSE, include = FALSE} -->
<!-- # dir.create("outputs") -->
<!-- # for (s in values$all_filtered_seurat_objects) { -->
<!-- #   sample_name <- s@meta.data$orig.ident[[1]] -->
<!-- #   SaveSeuratRds(s, paste0("outputs/", sample_name, ".filtered.Rds")) -->
<!-- # } -->
<!-- ``` -->
